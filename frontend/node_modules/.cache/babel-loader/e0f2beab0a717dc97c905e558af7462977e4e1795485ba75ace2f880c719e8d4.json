{"ast":null,"code":"import clipBuffer from \"./buffer\";\nimport clipPolygon from \"./polygon\";\nimport { epsilon, halfPi } from \"../math\";\nimport polygonContains from \"../polygonContains\";\nimport { merge } from \"d3-array\";\nexport default function (pointVisible, clipLine, interpolate, start) {\n  return function (rotate, sink) {\n    var line = clipLine(sink),\n      rotatedStart = rotate.invert(start[0], start[1]),\n      ringBuffer = clipBuffer(),\n      ringSink = clipLine(ringBuffer),\n      polygonStarted = false,\n      polygon,\n      segments,\n      ring;\n    var clip = {\n      point: point,\n      lineStart: lineStart,\n      lineEnd: lineEnd,\n      polygonStart: function () {\n        clip.point = pointRing;\n        clip.lineStart = ringStart;\n        clip.lineEnd = ringEnd;\n        segments = [];\n        polygon = [];\n      },\n      polygonEnd: function () {\n        clip.point = point;\n        clip.lineStart = lineStart;\n        clip.lineEnd = lineEnd;\n        segments = merge(segments);\n        var startInside = polygonContains(polygon, rotatedStart);\n        if (segments.length) {\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n          clipPolygon(segments, compareIntersection, startInside, interpolate, sink);\n        } else if (startInside) {\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n          sink.lineStart();\n          interpolate(null, null, 1, sink);\n          sink.lineEnd();\n        }\n        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;\n        segments = polygon = null;\n      },\n      sphere: function () {\n        sink.polygonStart();\n        sink.lineStart();\n        interpolate(null, null, 1, sink);\n        sink.lineEnd();\n        sink.polygonEnd();\n      }\n    };\n    function point(lambda, phi) {\n      var point = rotate(lambda, phi);\n      if (pointVisible(lambda = point[0], phi = point[1])) sink.point(lambda, phi);\n    }\n    function pointLine(lambda, phi) {\n      var point = rotate(lambda, phi);\n      line.point(point[0], point[1]);\n    }\n    function lineStart() {\n      clip.point = pointLine;\n      line.lineStart();\n    }\n    function lineEnd() {\n      clip.point = point;\n      line.lineEnd();\n    }\n    function pointRing(lambda, phi) {\n      ring.push([lambda, phi]);\n      var point = rotate(lambda, phi);\n      ringSink.point(point[0], point[1]);\n    }\n    function ringStart() {\n      ringSink.lineStart();\n      ring = [];\n    }\n    function ringEnd() {\n      pointRing(ring[0][0], ring[0][1]);\n      ringSink.lineEnd();\n      var clean = ringSink.clean(),\n        ringSegments = ringBuffer.result(),\n        i,\n        n = ringSegments.length,\n        m,\n        segment,\n        point;\n      ring.pop();\n      polygon.push(ring);\n      ring = null;\n      if (!n) return;\n\n      // No intersections.\n      if (clean & 1) {\n        segment = ringSegments[0];\n        if ((m = segment.length - 1) > 0) {\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n          sink.lineStart();\n          for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);\n          sink.lineEnd();\n        }\n        return;\n      }\n\n      // Rejoin connected segments.\n      // TODO reuse ringBuffer.rejoin()?\n      if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));\n      segments.push(ringSegments.filter(validSegment));\n    }\n    return clip;\n  };\n}\nfunction validSegment(segment) {\n  return segment.length > 1;\n}\n\n// Intersections are sorted along the clip edge. For both antimeridian cutting\n// and circle clipping, the same comparison is used.\nfunction compareIntersection(a, b) {\n  return ((a = a.x)[0] < 0 ? a[1] - halfPi - epsilon : halfPi - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfPi - epsilon : halfPi - b[1]);\n}","map":{"version":3,"names":["clipBuffer","clipPolygon","epsilon","halfPi","polygonContains","merge","pointVisible","clipLine","interpolate","start","rotate","sink","line","rotatedStart","invert","ringBuffer","ringSink","polygonStarted","polygon","segments","ring","clip","point","lineStart","lineEnd","polygonStart","pointRing","ringStart","ringEnd","polygonEnd","startInside","length","compareIntersection","sphere","lambda","phi","pointLine","push","clean","ringSegments","result","i","n","m","segment","pop","concat","shift","filter","validSegment","a","b","x"],"sources":["C:/my git/Design/frontend/node_modules/d3-geo/src/clip/index.js"],"sourcesContent":["import clipBuffer from \"./buffer\";\r\nimport clipPolygon from \"./polygon\";\r\nimport {epsilon, halfPi} from \"../math\";\r\nimport polygonContains from \"../polygonContains\";\r\nimport {merge} from \"d3-array\";\r\n\r\nexport default function(pointVisible, clipLine, interpolate, start) {\r\n  return function(rotate, sink) {\r\n    var line = clipLine(sink),\r\n        rotatedStart = rotate.invert(start[0], start[1]),\r\n        ringBuffer = clipBuffer(),\r\n        ringSink = clipLine(ringBuffer),\r\n        polygonStarted = false,\r\n        polygon,\r\n        segments,\r\n        ring;\r\n\r\n    var clip = {\r\n      point: point,\r\n      lineStart: lineStart,\r\n      lineEnd: lineEnd,\r\n      polygonStart: function() {\r\n        clip.point = pointRing;\r\n        clip.lineStart = ringStart;\r\n        clip.lineEnd = ringEnd;\r\n        segments = [];\r\n        polygon = [];\r\n      },\r\n      polygonEnd: function() {\r\n        clip.point = point;\r\n        clip.lineStart = lineStart;\r\n        clip.lineEnd = lineEnd;\r\n        segments = merge(segments);\r\n        var startInside = polygonContains(polygon, rotatedStart);\r\n        if (segments.length) {\r\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\r\n          clipPolygon(segments, compareIntersection, startInside, interpolate, sink);\r\n        } else if (startInside) {\r\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\r\n          sink.lineStart();\r\n          interpolate(null, null, 1, sink);\r\n          sink.lineEnd();\r\n        }\r\n        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;\r\n        segments = polygon = null;\r\n      },\r\n      sphere: function() {\r\n        sink.polygonStart();\r\n        sink.lineStart();\r\n        interpolate(null, null, 1, sink);\r\n        sink.lineEnd();\r\n        sink.polygonEnd();\r\n      }\r\n    };\r\n\r\n    function point(lambda, phi) {\r\n      var point = rotate(lambda, phi);\r\n      if (pointVisible(lambda = point[0], phi = point[1])) sink.point(lambda, phi);\r\n    }\r\n\r\n    function pointLine(lambda, phi) {\r\n      var point = rotate(lambda, phi);\r\n      line.point(point[0], point[1]);\r\n    }\r\n\r\n    function lineStart() {\r\n      clip.point = pointLine;\r\n      line.lineStart();\r\n    }\r\n\r\n    function lineEnd() {\r\n      clip.point = point;\r\n      line.lineEnd();\r\n    }\r\n\r\n    function pointRing(lambda, phi) {\r\n      ring.push([lambda, phi]);\r\n      var point = rotate(lambda, phi);\r\n      ringSink.point(point[0], point[1]);\r\n    }\r\n\r\n    function ringStart() {\r\n      ringSink.lineStart();\r\n      ring = [];\r\n    }\r\n\r\n    function ringEnd() {\r\n      pointRing(ring[0][0], ring[0][1]);\r\n      ringSink.lineEnd();\r\n\r\n      var clean = ringSink.clean(),\r\n          ringSegments = ringBuffer.result(),\r\n          i, n = ringSegments.length, m,\r\n          segment,\r\n          point;\r\n\r\n      ring.pop();\r\n      polygon.push(ring);\r\n      ring = null;\r\n\r\n      if (!n) return;\r\n\r\n      // No intersections.\r\n      if (clean & 1) {\r\n        segment = ringSegments[0];\r\n        if ((m = segment.length - 1) > 0) {\r\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\r\n          sink.lineStart();\r\n          for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);\r\n          sink.lineEnd();\r\n        }\r\n        return;\r\n      }\r\n\r\n      // Rejoin connected segments.\r\n      // TODO reuse ringBuffer.rejoin()?\r\n      if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));\r\n\r\n      segments.push(ringSegments.filter(validSegment));\r\n    }\r\n\r\n    return clip;\r\n  };\r\n}\r\n\r\nfunction validSegment(segment) {\r\n  return segment.length > 1;\r\n}\r\n\r\n// Intersections are sorted along the clip edge. For both antimeridian cutting\r\n// and circle clipping, the same comparison is used.\r\nfunction compareIntersection(a, b) {\r\n  return ((a = a.x)[0] < 0 ? a[1] - halfPi - epsilon : halfPi - a[1])\r\n       - ((b = b.x)[0] < 0 ? b[1] - halfPi - epsilon : halfPi - b[1]);\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}